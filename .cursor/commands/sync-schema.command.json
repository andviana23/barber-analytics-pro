{
  "name": "sync-schema",
  "description": "Analisa o banco via @pgsql e atualiza automaticamente o DATABASE_SCHEMA.md com a estrutura real",
  "prompt": "# üîÑ SINCRONIZAR SCHEMA DO BANCO COM DOCUMENTA√á√ÉO\n\nVoc√™ deve conectar ao banco **Supabase** via **@pgsql**, analisar a estrutura real das tabelas e atualizar automaticamente o arquivo **[DATABASE_SCHEMA.md](../docs/DATABASE_SCHEMA.md)** com as informa√ß√µes atualizadas.\n\n---\n\n## üéØ Objetivo\n\nGarantir que a documenta√ß√£o do schema esteja sempre sincronizada com a estrutura real do banco de dados, evitando diverg√™ncias que causam bugs e confus√£o.\n\n---\n\n## üîç Passos de Execu√ß√£o\n\n### **1. Conectar ao Banco via @pgsql**\n\nUse o conector MCP do Supabase configurado no Cursor:\n\n```sql\n-- Listar todas as tabelas do schema public\nSELECT table_name \nFROM information_schema.tables \nWHERE table_schema = 'public' \n  AND table_type = 'BASE TABLE'\nORDER BY table_name;\n```\n\n---\n\n### **2. Para Cada Tabela, Extrair Estrutura Completa**\n\n#### **A) Colunas**\n\n```sql\nSELECT \n  column_name,\n  data_type,\n  character_maximum_length,\n  numeric_precision,\n  numeric_scale,\n  is_nullable,\n  column_default,\n  udt_name -- Para ENUMs\nFROM information_schema.columns\nWHERE table_schema = 'public'\n  AND table_name = '{table_name}'\nORDER BY ordinal_position;\n```\n\n#### **B) Primary Keys**\n\n```sql\nSELECT \n  kcu.column_name\nFROM information_schema.table_constraints tc\nJOIN information_schema.key_column_usage kcu \n  ON tc.constraint_name = kcu.constraint_name\nWHERE tc.table_schema = 'public'\n  AND tc.table_name = '{table_name}'\n  AND tc.constraint_type = 'PRIMARY KEY';\n```\n\n#### **C) Foreign Keys**\n\n```sql\nSELECT \n  kcu.column_name AS column,\n  ccu.table_name AS referenced_table,\n  ccu.column_name AS referenced_column,\n  rc.update_rule,\n  rc.delete_rule\nFROM information_schema.table_constraints tc\nJOIN information_schema.key_column_usage kcu \n  ON tc.constraint_name = kcu.constraint_name\nJOIN information_schema.constraint_column_usage ccu \n  ON ccu.constraint_name = tc.constraint_name\nJOIN information_schema.referential_constraints rc \n  ON rc.constraint_name = tc.constraint_name\nWHERE tc.table_schema = 'public'\n  AND tc.table_name = '{table_name}'\n  AND tc.constraint_type = 'FOREIGN KEY';\n```\n\n#### **D) Constraints (CHECK)**\n\n```sql\nSELECT \n  conname AS constraint_name,\n  pg_get_constraintdef(oid) AS constraint_definition\nFROM pg_constraint\nWHERE conrelid = '{table_name}'::regclass\n  AND contype = 'c'; -- CHECK constraint\n```\n\n#### **E) Indexes**\n\n```sql\nSELECT \n  indexname,\n  indexdef\nFROM pg_indexes\nWHERE schemaname = 'public'\n  AND tablename = '{table_name}'\nORDER BY indexname;\n```\n\n#### **F) RLS Policies**\n\n```sql\nSELECT \n  policyname,\n  cmd AS operation,\n  qual AS using_clause,\n  with_check\nFROM pg_policies\nWHERE schemaname = 'public'\n  AND tablename = '{table_name}'\nORDER BY policyname;\n```\n\n#### **G) Triggers**\n\n```sql\nSELECT \n  trigger_name,\n  event_manipulation AS event,\n  action_timing AS timing,\n  action_statement\nFROM information_schema.triggers\nWHERE event_object_schema = 'public'\n  AND event_object_table = '{table_name}'\nORDER BY trigger_name;\n```\n\n---\n\n### **3. Extrair Informa√ß√µes de ENUMs**\n\n```sql\nSELECT \n  t.typname AS enum_name,\n  array_agg(e.enumlabel ORDER BY e.enumsortorder) AS enum_values\nFROM pg_type t\nJOIN pg_enum e ON t.oid = e.enumtypid\nWHERE t.typtype = 'e'\nGROUP BY t.typname\nORDER BY t.typname;\n```\n\n---\n\n### **4. Extrair Informa√ß√µes de Views**\n\n```sql\nSELECT \n  table_name AS view_name,\n  view_definition\nFROM information_schema.views\nWHERE table_schema = 'public'\nORDER BY table_name;\n```\n\n---\n\n### **5. Extrair Informa√ß√µes de Functions**\n\n```sql\nSELECT \n  routine_name AS function_name,\n  routine_definition AS function_body,\n  data_type AS return_type\nFROM information_schema.routines\nWHERE routine_schema = 'public'\n  AND routine_type = 'FUNCTION'\nORDER BY routine_name;\n```\n\n---\n\n## üìù Formato do DATABASE_SCHEMA.md\n\n### **Template de Se√ß√£o para Cada Tabela**\n\n```markdown\n### **{table_name}** ({Descri√ß√£o em Portugu√™s})\n\n> {Descri√ß√£o detalhada da entidade de neg√≥cio}\n\n```sql\nCREATE TABLE {table_name} (\n  -- Primary Key\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  \n  -- Campos obrigat√≥rios\n  campo1 {tipo} NOT NULL,\n  campo2 {tipo} NOT NULL,\n  \n  -- Campos opcionais\n  campo3 {tipo},\n  campo4 {tipo},\n  \n  -- Foreign Keys\n  unit_id UUID NOT NULL REFERENCES units(id) ON DELETE CASCADE,\n  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,\n  \n  -- Metadados\n  created_at TIMESTAMP DEFAULT NOW() NOT NULL,\n  updated_at TIMESTAMP DEFAULT NOW() NOT NULL,\n  is_active BOOLEAN DEFAULT TRUE NOT NULL,\n  \n  -- Constraints\n  CONSTRAINT {table_name}_{constraint_name} CHECK ({express√£o})\n);\n```\n\n**ENUMs Utilizados:**\n- `{enum_name}`: `['valor1', 'valor2', 'valor3']`\n\n**√çndices:**\n```sql\nCREATE INDEX idx_{table_name}_{column} ON {table_name}({column});\nCREATE INDEX idx_{table_name}_{col1}_{col2} ON {table_name}({col1}, {col2});\n```\n\n**RLS Policies:**\n```sql\n-- Isolamento por unidade\nCREATE POLICY \"policy_{table_name}_unit_access\" \n  ON {table_name}\n  FOR ALL\n  USING (unit_id IN (SELECT unit_id FROM professionals WHERE user_id = auth.uid()));\n\n-- Acesso admin\nCREATE POLICY \"policy_{table_name}_admin_access\" \n  ON {table_name}\n  FOR ALL\n  USING (get_user_role() = 'admin');\n```\n\n**Triggers:**\n```sql\nCREATE TRIGGER trigger_{table_name}_update_timestamp\n  BEFORE UPDATE ON {table_name}\n  FOR EACH ROW\n  EXECUTE FUNCTION fn_update_timestamp();\n```\n\n---\n\n## üìä Estat√≠sticas de Uso**\n\n```sql\n-- N√∫mero de registros\nSELECT COUNT(*) FROM {table_name};\n\n-- Tamanho da tabela\nSELECT pg_size_pretty(pg_total_relation_size('{table_name}'));\n```\n\n**Registros:** {count}\n**Tamanho:** {size}\n\n---\n```\n\n---\n\n## üîÑ Algoritmo de Sincroniza√ß√£o\n\n```javascript\n// Pseudo-c√≥digo do processo de sincroniza√ß√£o\n\nasync function syncDatabaseSchema() {\n  // 1. Conectar ao banco via @pgsql\n  const connection = await connectSupabase();\n  \n  // 2. Listar todas as tabelas\n  const tables = await connection.query(`\n    SELECT table_name \n    FROM information_schema.tables \n    WHERE table_schema = 'public' \n      AND table_type = 'BASE TABLE'\n  `);\n  \n  // 3. Para cada tabela, extrair estrutura completa\n  const schemaData = {};\n  \n  for (const table of tables) {\n    const tableName = table.table_name;\n    \n    schemaData[tableName] = {\n      columns: await getColumns(tableName),\n      primaryKeys: await getPrimaryKeys(tableName),\n      foreignKeys: await getForeignKeys(tableName),\n      constraints: await getConstraints(tableName),\n      indexes: await getIndexes(tableName),\n      policies: await getRLSPolicies(tableName),\n      triggers: await getTriggers(tableName),\n      stats: await getTableStats(tableName)\n    };\n  }\n  \n  // 4. Extrair ENUMs globais\n  const enums = await getEnums();\n  \n  // 5. Extrair Views\n  const views = await getViews();\n  \n  // 6. Extrair Functions\n  const functions = await getFunctions();\n  \n  // 7. Gerar Markdown a partir dos dados\n  const markdownContent = generateMarkdown({\n    tables: schemaData,\n    enums,\n    views,\n    functions\n  });\n  \n  // 8. Atualizar DATABASE_SCHEMA.md\n  await fs.writeFile('docs/DATABASE_SCHEMA.md', markdownContent);\n  \n  console.log('‚úÖ DATABASE_SCHEMA.md atualizado com sucesso!');\n}\n```\n\n---\n\n## üß™ Valida√ß√£o P√≥s-Sincroniza√ß√£o\n\n### **Checklist de Valida√ß√£o**\n\n- [ ] Todas as tabelas do banco est√£o documentadas\n- [ ] Todos os campos de cada tabela est√£o listados\n- [ ] Tipos de dados est√£o corretos (VARCHAR, NUMERIC, UUID, etc.)\n- [ ] ENUMs est√£o documentados com todos os valores poss√≠veis\n- [ ] Foreign Keys est√£o mapeadas corretamente\n- [ ] Constraints (CHECK, UNIQUE) est√£o documentadas\n- [ ] √çndices est√£o listados\n- [ ] Pol√≠ticas RLS est√£o documentadas\n- [ ] Triggers est√£o documentados\n- [ ] Views est√£o documentadas\n- [ ] Functions est√£o documentadas\n- [ ] Estat√≠sticas de uso est√£o atualizadas\n\n### **Diff com Vers√£o Anterior**\n\n```bash\n# Comparar com vers√£o anterior\ngit diff docs/DATABASE_SCHEMA.md\n\n# Ver mudan√ßas estruturais\ngit diff --word-diff docs/DATABASE_SCHEMA.md\n```\n\n---\n\n## üö® Alertas a Gerar\n\n### **Diverg√™ncias Cr√≠ticas**\n\n```markdown\n## ‚ö†Ô∏è ALERTAS DE SINCRONIZA√á√ÉO\n\n### üî¥ Tabelas no Banco N√£o Documentadas:\n- `new_table_1` (criada em {data})\n- `new_table_2` (criada em {data})\n\n### üî¥ Colunas Adicionadas:\n- `revenues.new_column` (tipo: VARCHAR(255), nullable: YES)\n- `expenses.another_column` (tipo: NUMERIC(10,2), nullable: NO)\n\n### üü° Colunas Removidas:\n- `revenues.old_column` (removida em {data})\n\n### üü° √çndices Faltando:\n- `revenues` precisa de √≠ndice em `account_id`\n- `expenses` precisa de √≠ndice composto em `unit_id, date`\n\n### üîµ RLS Desabilitado:\n- `new_table_1` n√£o tem RLS ativo (CR√çTICO!)\n\n### üîµ Policies Faltando:\n- `clients` n√£o tem policy de isolamento por unidade\n```\n\n---\n\n## üîó Integra√ß√£o com CI/CD\n\n### **GitHub Actions Workflow**\n\n```yaml\nname: Sync Database Schema\n\non:\n  schedule:\n    - cron: '0 0 * * 0' # Todo domingo √† meia-noite\n  workflow_dispatch: # Permite execu√ß√£o manual\n\njobs:\n  sync-schema:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Setup Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: '20'\n      \n      - name: Install dependencies\n        run: npm install\n      \n      - name: Sync Database Schema\n        run: node scripts/sync-database-schema.js\n        env:\n          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}\n          SUPABASE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}\n      \n      - name: Commit changes\n        run: |\n          git config --local user.email \"action@github.com\"\n          git config --local user.name \"GitHub Action\"\n          git add docs/DATABASE_SCHEMA.md\n          git commit -m \"chore: sync database schema [skip ci]\" || exit 0\n          git push\n```\n\n---\n\n## ‚úÖ Checklist Final\n\n- [ ] Conectou ao banco via @pgsql\n- [ ] Listou todas as tabelas\n- [ ] Extraiu estrutura de cada tabela (colunas, PKs, FKs, constraints)\n- [ ] Extraiu √≠ndices\n- [ ] Extraiu pol√≠ticas RLS\n- [ ] Extraiu triggers\n- [ ] Extraiu ENUMs\n- [ ] Extraiu Views\n- [ ] Extraiu Functions\n- [ ] Gerou Markdown formatado\n- [ ] Atualizou DATABASE_SCHEMA.md\n- [ ] Gerou alertas de diverg√™ncias\n- [ ] Validou integridade da documenta√ß√£o\n\n---\n\n**IMPORTANTE:** Execute este comando **semanalmente** ou ap√≥s **qualquer migra√ß√£o de banco** para manter a documenta√ß√£o sincronizada.\n"
}
