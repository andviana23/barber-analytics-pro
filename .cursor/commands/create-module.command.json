{
  "name": "create-module",
  "description": "Gera um m√≥dulo completo seguindo Clean Architecture + DDD (DTO ‚Üí Service ‚Üí Repository ‚Üí Hook ‚Üí Page)",
  "prompt": "# üß© CRIAR M√ìDULO COMPLETO\n\nVoc√™ deve criar um m√≥dulo completo no projeto **BARBER-ANALYTICS-PRO** seguindo rigorosamente os padr√µes de **Clean Architecture**, **DDD**, **CQRS** e **SOLID**.\n\n## üìã Entrada Esperada\n\nO usu√°rio fornecer√°:\n1. **Nome do m√≥dulo** (ex: `clients`, `inventory`, `reports`)\n2. **Descri√ß√£o breve** do dom√≠nio de neg√≥cio\n3. **Entidade principal** com seus campos e tipos\n4. **Opera√ß√µes CRUD** necess√°rias (create, read, update, delete)\n\n---\n\n## üèóÔ∏è Estrutura a Ser Gerada\n\nCrie os seguintes arquivos automaticamente:\n\n### **1. DTO (Data Transfer Object)**\nüìÅ `src/dtos/{moduleName}DTO.js`\n\n```javascript\n/**\n * DTOs para {ModuleName}\n * \n * Define contratos expl√≠citos entre camadas:\n * - Front-end ‚Üí Service (Create{ModuleName}DTO)\n * - Service ‚Üí Front-end ({ModuleName}ResponseDTO)\n */\n\n// WHITELIST: Colunas permitidas na tabela {table_name}\nexport const ALLOWED_{MODULE}_COLUMNS = [\n  // Campos obrigat√≥rios\n  'field1',\n  'field2',\n  // Relacionamentos\n  'unit_id',\n  'user_id'\n];\n\n// BLACKLIST: Campos proibidos\nexport const FORBIDDEN_{MODULE}_FIELDS = [\n  'id',\n  'created_at',\n  'updated_at'\n];\n\n/**\n * DTO para cria√ß√£o\n */\nexport class Create{ModuleName}DTO {\n  constructor(data) {\n    // Mapear campos do input\n    this.field1 = data.field1;\n    this.field2 = data.field2;\n    this.unit_id = data.unit_id;\n  }\n\n  validate() {\n    const errors = [];\n    \n    // Valida√ß√µes de neg√≥cio\n    if (!this.field1) {\n      errors.push('Campo \"field1\" √© obrigat√≥rio');\n    }\n    \n    return {\n      isValid: errors.length === 0,\n      errors\n    };\n  }\n\n  toDatabase() {\n    const dbObject = {};\n    \n    for (const [key, value] of Object.entries(this)) {\n      if (FORBIDDEN_{MODULE}_FIELDS.includes(key)) continue;\n      if (!ALLOWED_{MODULE}_COLUMNS.includes(key)) continue;\n      if (value !== null && value !== undefined) {\n        dbObject[key] = value;\n      }\n    }\n    \n    return dbObject;\n  }\n}\n\n/**\n * DTO para resposta\n */\nexport class {ModuleName}ResponseDTO {\n  constructor(dbRecord) {\n    this.id = dbRecord.id;\n    this.field1 = dbRecord.field1;\n    this.field2 = dbRecord.field2;\n    this.created_at = dbRecord.created_at;\n  }\n\n  toPlainObject() {\n    return {\n      id: this.id,\n      field1: this.field1,\n      field2: this.field2,\n      created_at: this.created_at\n    };\n  }\n}\n```\n\n---\n\n### **2. Repository (Camada de Infraestrutura)**\nüìÅ `src/repositories/{moduleName}Repository.js`\n\n```javascript\nimport { supabase } from '../services/supabase';\nimport { ALLOWED_{MODULE}_COLUMNS, FORBIDDEN_{MODULE}_FIELDS } from '../dtos/{moduleName}DTO';\n\n/**\n * {ModuleName}Repository - Repository Pattern\n * \n * Encapsula toda a l√≥gica de acesso ao banco de dados para a entidade {ModuleName}.\n */\nclass {ModuleName}Repository {\n  tableName = '{table_name}';\n  defaultTimeout = 10000;\n\n  normalizeError(error) {\n    if (!error) return 'Erro desconhecido';\n    if (error.code === '23505') return 'Registro duplicado';\n    if (error.code === '23503') return 'Refer√™ncia inv√°lida';\n    return error.message || 'Erro interno do sistema';\n  }\n\n  async create(data) {\n    try {\n      console.log('üè¶ Repository: Criando {moduleName}...');\n      \n      // Sanitiza√ß√£o\n      const sanitizedData = {};\n      for (const [key, value] of Object.entries(data)) {\n        if (FORBIDDEN_{MODULE}_FIELDS.includes(key)) continue;\n        if (!ALLOWED_{MODULE}_COLUMNS.includes(key)) continue;\n        if (value !== null && value !== undefined) {\n          sanitizedData[key] = value;\n        }\n      }\n\n      const { data: record, error } = await supabase\n        .from(this.tableName)\n        .insert(sanitizedData)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('‚ùå Repository: Erro do Supabase:', error);\n        return { data: null, error: this.normalizeError(error) };\n      }\n\n      console.log('‚úÖ Repository: {ModuleName} criado com ID:', record.id);\n      return { data: record, error: null };\n\n    } catch (err) {\n      console.error('‚ùå Repository: Exce√ß√£o inesperada:', err);\n      return { data: null, error: 'Erro inesperado ao salvar registro' };\n    }\n  }\n\n  async findAll(filters = {}, pagination = { page: 1, limit: 50 }) {\n    try {\n      console.log('üè¶ Repository: Buscando {moduleName}s com filtros:', filters);\n\n      let query = supabase\n        .from(this.tableName)\n        .select('*', { count: 'exact' });\n\n      // Aplicar filtros\n      if (filters.unit_id) query = query.eq('unit_id', filters.unit_id);\n\n      // Pagina√ß√£o\n      const { page, limit } = pagination;\n      const from = (page - 1) * limit;\n      const to = from + limit - 1;\n      query = query.range(from, to);\n\n      const { data, error, count } = await query;\n\n      if (error) {\n        console.error('‚ùå Repository: Erro ao buscar:', error);\n        return { data: [], error: error.message, count: 0 };\n      }\n\n      console.log(`‚úÖ Repository: ${data.length} registros encontrados (total: ${count})`);\n      return { data: data || [], error: null, count: count || 0 };\n\n    } catch (err) {\n      console.error('‚ùå Repository: Erro inesperado:', err);\n      return { data: [], error: 'Erro inesperado ao buscar registros', count: 0 };\n    }\n  }\n\n  async findById(id) {\n    try {\n      const { data, error } = await supabase\n        .from(this.tableName)\n        .select('*')\n        .eq('id', id)\n        .single();\n\n      if (error) return { data: null, error: 'Registro n√£o encontrado' };\n      return { data, error: null };\n\n    } catch (err) {\n      return { data: null, error: 'Erro ao buscar registro' };\n    }\n  }\n\n  async update(id, data) {\n    try {\n      const { data: record, error } = await supabase\n        .from(this.tableName)\n        .update(data)\n        .eq('id', id)\n        .select()\n        .single();\n\n      if (error) return { data: null, error: 'Erro ao atualizar registro' };\n      return { data: record, error: null };\n\n    } catch (err) {\n      return { data: null, error: 'Erro inesperado ao atualizar' };\n    }\n  }\n\n  async softDelete(id) {\n    try {\n      const { error } = await supabase\n        .from(this.tableName)\n        .update({ is_active: false })\n        .eq('id', id);\n\n      if (error) return { success: false, error: 'Erro ao desativar registro' };\n      return { success: true, error: null };\n\n    } catch (err) {\n      return { success: false, error: 'Erro inesperado ao desativar' };\n    }\n  }\n}\n\nexport default new {ModuleName}Repository();\n```\n\n---\n\n### **3. Service (Camada de Aplica√ß√£o)**\nüìÅ `src/services/{moduleName}Service.js`\n\n```javascript\nimport { Create{ModuleName}DTO, {ModuleName}ResponseDTO } from '../dtos/{moduleName}DTO';\nimport {moduleName}Repository from '../repositories/{moduleName}Repository';\n\n/**\n * {ModuleName}Service - Service Layer (Orquestrador)\n * \n * Responsabilidades:\n * - Orquestrar fluxo de neg√≥cio\n * - Validar dados usando DTOs\n * - Delegar persist√™ncia ao Repository\n * - Aplicar regras de neg√≥cio\n */\nclass {ModuleName}Service {\n  async getAll(filters = {}, pagination = null) {\n    try {\n      console.log('üîÑ Service: Buscando {moduleName}s...', filters);\n      \n      const result = await {moduleName}Repository.findAll(filters, pagination);\n      const { data, error, count } = result;\n      \n      if (error) {\n        console.error('‚ùå Service: Erro ao buscar:', error);\n        return { data: [], error, count: 0 };\n      }\n      \n      const records = (data || []).map(record => new {ModuleName}ResponseDTO(record).toPlainObject());\n      \n      console.log(`‚úÖ Service: ${records.length} {moduleName}s transformados em DTOs`);\n      return { data: records, error: null, count };\n      \n    } catch (err) {\n      console.error('‚ùå Service: Erro inesperado:', err);\n      return { data: [], error: err.message, count: 0 };\n    }\n  }\n  \n  async create(inputData) {\n    try {\n      console.log('üîç Service: Criando {moduleName}...');\n      \n      // Criar DTO\n      const dto = new Create{ModuleName}DTO(inputData);\n      \n      // Validar\n      const validation = dto.validate();\n      if (!validation.isValid) {\n        console.error('‚ùå Valida√ß√£o falhou:', validation.errors);\n        return { data: null, error: validation.errors.join(' | ') };\n      }\n      \n      // Transformar para banco\n      const dbData = dto.toDatabase();\n      \n      // Delegar ao Repository\n      const { data, error } = await {moduleName}Repository.create(dbData);\n      \n      if (error) {\n        console.error('‚ùå Service: Erro do Repository:', error);\n        return { data: null, error };\n      }\n      \n      // Criar DTO de resposta\n      const responseDTO = new {ModuleName}ResponseDTO(data);\n      console.log('‚úÖ Service: {ModuleName} criado com sucesso!');\n      \n      return { data: responseDTO.toPlainObject(), error: null };\n      \n    } catch (err) {\n      console.error('‚ùå Service: Erro inesperado:', err);\n      return { data: null, error: 'Erro inesperado ao criar {moduleName}' };\n    }\n  }\n\n  async getById(id) {\n    try {\n      const { data, error } = await {moduleName}Repository.findById(id);\n      if (error) return { data: null, error };\n      \n      const dto = new {ModuleName}ResponseDTO(data);\n      return { data: dto.toPlainObject(), error: null };\n      \n    } catch (err) {\n      return { data: null, error: err.message };\n    }\n  }\n\n  async update(id, updateData) {\n    try {\n      const { data, error } = await {moduleName}Repository.update(id, updateData);\n      if (error) return { data: null, error };\n      \n      const dto = new {ModuleName}ResponseDTO(data);\n      return { data: dto.toPlainObject(), error: null };\n      \n    } catch (err) {\n      return { data: null, error: err.message };\n    }\n  }\n\n  async delete(id) {\n    try {\n      const { success, error } = await {moduleName}Repository.softDelete(id);\n      if (!success) return { success: false, error };\n      \n      return { success: true, error: null };\n      \n    } catch (err) {\n      return { success: false, error: err.message };\n    }\n  }\n}\n\nexport default new {ModuleName}Service();\n```\n\n---\n\n### **4. Custom Hook (React)**\nüìÅ `src/hooks/use{ModuleName}.js`\n\n```javascript\nimport { useState, useCallback, useEffect } from 'react';\nimport {moduleName}Service from '../services/{moduleName}Service';\n\n/**\n * Custom Hook para gest√£o de {moduleName}s\n * \n * Encapsula estado e l√≥gica de neg√≥cio para uso nos componentes React\n */\nexport const use{ModuleName} = (filters = {}, options = {}) => {\n  const [data, setData] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [pagination, setPagination] = useState({\n    page: 1,\n    limit: 50,\n    total: 0\n  });\n  \n  const fetchData = useCallback(async (page = 1) => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const result = await {moduleName}Service.getAll(\n        filters, \n        { page, limit: pagination.limit }\n      );\n      \n      if (result.error) {\n        setError(result.error);\n        return;\n      }\n      \n      setData(result.data);\n      setPagination(prev => ({\n        ...prev,\n        page,\n        total: result.count\n      }));\n      \n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [filters, pagination.limit]);\n  \n  // Auto-fetch quando filtros mudam\n  useEffect(() => {\n    if (options.autoFetch !== false) {\n      fetchData(1);\n    }\n  }, [fetchData, options.autoFetch]);\n  \n  const create = useCallback(async (data) => {\n    const result = await {moduleName}Service.create(data);\n    if (result.data) {\n      setData(prev => [result.data, ...prev]);\n    }\n    return result;\n  }, []);\n  \n  const update = useCallback(async (id, data) => {\n    const result = await {moduleName}Service.update(id, data);\n    if (result.data) {\n      setData(prev => prev.map(item => \n        item.id === id ? result.data : item\n      ));\n    }\n    return result;\n  }, []);\n  \n  const remove = useCallback(async (id) => {\n    const result = await {moduleName}Service.delete(id);\n    if (result.success) {\n      setData(prev => prev.filter(item => item.id !== id));\n    }\n    return result;\n  }, []);\n  \n  return {\n    data,\n    loading,\n    error,\n    pagination,\n    refetch: fetchData,\n    create,\n    update,\n    remove,\n    hasData: data.length > 0,\n    isEmpty: !loading && data.length === 0,\n    hasError: !!error\n  };\n};\n```\n\n---\n\n### **5. Page Component (React)**\nüìÅ `src/pages/{ModuleName}Page/{ModuleName}Page.jsx`\n\n```jsx\nimport React, { useState } from 'react';\nimport { use{ModuleName} } from '../../hooks/use{ModuleName}';\n\nexport const {ModuleName}Page = () => {\n  const [filters, setFilters] = useState({});\n  const { \n    data, \n    loading, \n    error, \n    create, \n    update, \n    remove,\n    refetch \n  } = use{ModuleName}(filters);\n\n  const handleCreate = async (formData) => {\n    const result = await create(formData);\n    if (result.error) {\n      alert('Erro ao criar: ' + result.error);\n    } else {\n      alert('Criado com sucesso!');\n      refetch();\n    }\n  };\n\n  if (loading) return <div>Carregando...</div>;\n  if (error) return <div>Erro: {error}</div>;\n\n  return (\n    <div className=\"{moduleName}-page\">\n      <h1>{ModuleName}s</h1>\n      \n      {/* Formul√°rio de cria√ß√£o */}\n      <form onSubmit={(e) => {\n        e.preventDefault();\n        const formData = new FormData(e.target);\n        handleCreate(Object.fromEntries(formData));\n      }}>\n        <input name=\"field1\" placeholder=\"Field 1\" required />\n        <input name=\"field2\" placeholder=\"Field 2\" />\n        <button type=\"submit\">Criar</button>\n      </form>\n\n      {/* Lista de registros */}\n      <table>\n        <thead>\n          <tr>\n            <th>ID</th>\n            <th>Field 1</th>\n            <th>Field 2</th>\n            <th>A√ß√µes</th>\n          </tr>\n        </thead>\n        <tbody>\n          {data.map(item => (\n            <tr key={item.id}>\n              <td>{item.id}</td>\n              <td>{item.field1}</td>\n              <td>{item.field2}</td>\n              <td>\n                <button onClick={() => remove(item.id)}>Deletar</button>\n              </td>\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n};\n```\n\n---\n\n## ‚úÖ Checklist de Valida√ß√£o\n\nAp√≥s gerar os arquivos, valide:\n\n- [ ] DTO implementa valida√ß√£o completa\n- [ ] Repository aplica whitelist/blacklist\n- [ ] Service n√£o acessa banco diretamente\n- [ ] Hook encapsula estado React corretamente\n- [ ] Page usa apenas o hook (n√£o service diretamente)\n- [ ] Todos os arquivos seguem padr√£o de nomenclatura\n- [ ] Imports est√£o corretos\n- [ ] Logs de debug est√£o presentes\n\n---\n\n## üìö Refer√™ncias\n\n- [ARCHITECTURE.md](../docs/ARCHITECTURE.md)\n- [DATABASE_SCHEMA.md](../docs/DATABASE_SCHEMA.md)\n- [FINANCIAL_MODULE.md](../docs/FINANCIAL_MODULE.md)\n- [CLAUDE.md](../CLAUDE.md)\n\n---\n\n**IMPORTANTE:** Substitua todos os placeholders:\n- `{moduleName}` ‚Üí Nome do m√≥dulo (camelCase)\n- `{ModuleName}` ‚Üí Nome do m√≥dulo (PascalCase)\n- `{MODULE}` ‚Üí Nome do m√≥dulo (UPPERCASE)\n- `{table_name}` ‚Üí Nome da tabela no banco (snake_case)\n- `field1`, `field2` ‚Üí Campos reais da entidade\n"
}
