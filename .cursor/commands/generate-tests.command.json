{
  "name": "generate-tests",
  "description": "Cria testes unitários e de integração para os módulos indicados (cobertura mínima de 80%)",
  "prompt": "# 🧪 GERAR TESTES AUTOMATICAMENTE\n\nVocê deve gerar **testes unitários** e **testes de integração** completos para o módulo especificado, seguindo o padrão do projeto **BARBER-ANALYTICS-PRO**.\n\n## 📋 Entrada Esperada\n\nO usuário fornecerá:\n1. **Módulo a testar** (ex: `financeiroService`, `revenueRepository`, `revenueDTO`)\n2. **Tipo de teste** (unit, integration, e2e)\n3. **Cobertura mínima** (padrão: 80%)\n\n---\n\n## 🏗️ Estrutura de Testes\n\n### **Estrutura de Pastas**\n\n```\nsrc/\n  services/\n    financeiroService.js\n  repositories/\n    revenueRepository.js\n  dtos/\n    revenueDTO.js\n  __tests__/\n    unit/\n      services/\n        financeiroService.spec.ts\n      repositories/\n        revenueRepository.spec.ts\n      dtos/\n        revenueDTO.spec.ts\n    integration/\n      financial-flow.spec.ts\n      revenue-lifecycle.spec.ts\n    e2e/\n      create-revenue.spec.ts\n```\n\n---\n\n## 🧪 Testes Unitários\n\n### **1. Testes de DTO**\n\n**Arquivo:** `src/dtos/__tests__/revenueDTO.spec.ts`\n\n```typescript\nimport { CreateRevenueDTO, RevenueResponseDTO, ALLOWED_REVENUE_COLUMNS, FORBIDDEN_REVENUE_FIELDS } from '../revenueDTO';\n\ndescribe('CreateRevenueDTO', () => {\n  describe('Constructor', () => {\n    it('should create DTO with valid data', () => {\n      const data = {\n        type: 'service',\n        value: 150.00,\n        date: '2025-10-18',\n        unit_id: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890'\n      };\n      \n      const dto = new CreateRevenueDTO(data);\n      \n      expect(dto.type).toBe('service');\n      expect(dto.value).toBe(150.00);\n      expect(dto.date).toBe('2025-10-18');\n      expect(dto.unit_id).toBe('a1b2c3d4-e5f6-7890-abcd-ef1234567890');\n    });\n    \n    it('should handle null/undefined data gracefully', () => {\n      const dto = new CreateRevenueDTO(null);\n      expect(dto).toBeDefined();\n    });\n    \n    it('should set default date if not provided', () => {\n      const dto = new CreateRevenueDTO({ type: 'service', value: 100 });\n      expect(dto.date).toMatch(/^\\d{4}-\\d{2}-\\d{2}$/);\n    });\n  });\n  \n  describe('validate()', () => {\n    it('should pass validation with valid data', () => {\n      const dto = new CreateRevenueDTO({\n        type: 'service',\n        value: 150.00,\n        date: '2025-10-18'\n      });\n      \n      const result = dto.validate();\n      \n      expect(result.isValid).toBe(true);\n      expect(result.errors).toHaveLength(0);\n    });\n    \n    it('should fail validation when type is missing', () => {\n      const dto = new CreateRevenueDTO({\n        value: 150.00,\n        date: '2025-10-18'\n      });\n      \n      const result = dto.validate();\n      \n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('Campo \"type\" é obrigatório');\n    });\n    \n    it('should fail validation when value is zero', () => {\n      const dto = new CreateRevenueDTO({\n        type: 'service',\n        value: 0,\n        date: '2025-10-18'\n      });\n      \n      const result = dto.validate();\n      \n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('Campo \"value\" deve ser maior que zero');\n    });\n    \n    it('should fail validation when value is negative', () => {\n      const dto = new CreateRevenueDTO({\n        type: 'service',\n        value: -100,\n        date: '2025-10-18'\n      });\n      \n      const result = dto.validate();\n      \n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('Campo \"value\" deve ser maior que zero');\n    });\n    \n    it('should fail validation when type is invalid', () => {\n      const dto = new CreateRevenueDTO({\n        type: 'invalid_type',\n        value: 150.00,\n        date: '2025-10-18'\n      });\n      \n      const result = dto.validate();\n      \n      expect(result.isValid).toBe(false);\n      expect(result.errors[0]).toContain('valores válidos');\n    });\n    \n    it('should fail validation when date format is invalid', () => {\n      const dto = new CreateRevenueDTO({\n        type: 'service',\n        value: 150.00,\n        date: '18/10/2025' // Formato errado\n      });\n      \n      const result = dto.validate();\n      \n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('Campo \"date\" deve estar no formato YYYY-MM-DD');\n    });\n    \n    it('should fail validation when UUID is invalid', () => {\n      const dto = new CreateRevenueDTO({\n        type: 'service',\n        value: 150.00,\n        date: '2025-10-18',\n        unit_id: 'not-a-uuid'\n      });\n      \n      const result = dto.validate();\n      \n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('Campo \"unit_id\" deve estar no formato UUID válido');\n    });\n  });\n  \n  describe('toDatabase()', () => {\n    it('should convert DTO to database object', () => {\n      const dto = new CreateRevenueDTO({\n        type: 'service',\n        value: 150.00,\n        date: '2025-10-18',\n        unit_id: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890'\n      });\n      \n      const dbObject = dto.toDatabase();\n      \n      expect(dbObject).toHaveProperty('type', 'service');\n      expect(dbObject).toHaveProperty('value', 150.00);\n      expect(dbObject).toHaveProperty('date', '2025-10-18');\n      expect(dbObject).toHaveProperty('unit_id', 'a1b2c3d4-e5f6-7890-abcd-ef1234567890');\n    });\n    \n    it('should remove forbidden fields', () => {\n      const dto = new CreateRevenueDTO({\n        type: 'service',\n        value: 150.00,\n        date: '2025-10-18',\n        id: 'should-be-removed', // Campo proibido\n        created_at: 'should-be-removed' // Campo proibido\n      });\n      \n      const dbObject = dto.toDatabase();\n      \n      expect(dbObject).not.toHaveProperty('id');\n      expect(dbObject).not.toHaveProperty('created_at');\n    });\n    \n    it('should only include whitelisted fields', () => {\n      const dto = new CreateRevenueDTO({\n        type: 'service',\n        value: 150.00,\n        date: '2025-10-18',\n        malicious_field: 'should-be-ignored' // Campo não permitido\n      });\n      \n      const dbObject = dto.toDatabase();\n      \n      expect(dbObject).not.toHaveProperty('malicious_field');\n    });\n  });\n});\n\ndescribe('RevenueResponseDTO', () => {\n  it('should create response DTO from database record', () => {\n    const dbRecord = {\n      id: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',\n      type: 'service',\n      value: '150.00', // Vem como string do BD\n      date: '2025-10-18',\n      status: 'Pending',\n      created_at: '2025-10-18T14:30:00.000Z'\n    };\n    \n    const dto = new RevenueResponseDTO(dbRecord);\n    \n    expect(dto.id).toBe('a1b2c3d4-e5f6-7890-abcd-ef1234567890');\n    expect(dto.type).toBe('service');\n    expect(dto.value).toBe(150.00); // Convertido para number\n    expect(dto.status).toBe('Pending');\n  });\n  \n  it('should convert to plain object', () => {\n    const dbRecord = {\n      id: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',\n      type: 'service',\n      value: '150.00',\n      date: '2025-10-18',\n      status: 'Pending',\n      created_at: '2025-10-18T14:30:00.000Z'\n    };\n    \n    const dto = new RevenueResponseDTO(dbRecord);\n    const plain = dto.toPlainObject();\n    \n    expect(plain).toEqual(expect.objectContaining({\n      id: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890',\n      type: 'service',\n      value: 150.00,\n      status: 'Pending'\n    }));\n  });\n});\n```\n\n---\n\n### **2. Testes de Repository**\n\n**Arquivo:** `src/repositories/__tests__/revenueRepository.spec.ts`\n\n```typescript\nimport revenueRepository from '../revenueRepository';\nimport { supabase } from '../../services/supabase';\n\n// Mock do Supabase\njest.mock('../../services/supabase', () => ({\n  supabase: {\n    from: jest.fn(() => ({\n      insert: jest.fn(() => ({\n        select: jest.fn(() => ({\n          single: jest.fn()\n        }))\n      })),\n      select: jest.fn(() => ({\n        eq: jest.fn(() => ({\n          single: jest.fn()\n        }))\n      }))\n    }))\n  }\n}));\n\ndescribe('RevenueRepository', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  describe('create()', () => {\n    it('should create revenue successfully', async () => {\n      const mockData = {\n        type: 'service',\n        value: 150.00,\n        date: '2025-10-18',\n        unit_id: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890'\n      };\n      \n      const mockResponse = {\n        id: 'new-id',\n        ...mockData,\n        created_at: '2025-10-18T14:30:00.000Z'\n      };\n      \n      (supabase.from as jest.Mock).mockReturnValue({\n        insert: jest.fn().mockReturnValue({\n          select: jest.fn().mockReturnValue({\n            single: jest.fn().mockResolvedValue({\n              data: mockResponse,\n              error: null\n            })\n          })\n        })\n      });\n      \n      const result = await revenueRepository.create(mockData);\n      \n      expect(result.data).toEqual(mockResponse);\n      expect(result.error).toBeNull();\n    });\n    \n    it('should handle database errors', async () => {\n      const mockData = {\n        type: 'service',\n        value: 150.00,\n        date: '2025-10-18'\n      };\n      \n      (supabase.from as jest.Mock).mockReturnValue({\n        insert: jest.fn().mockReturnValue({\n          select: jest.fn().mockReturnValue({\n            single: jest.fn().mockResolvedValue({\n              data: null,\n              error: { code: '23503', message: 'Foreign key violation' }\n            })\n          })\n        })\n      });\n      \n      const result = await revenueRepository.create(mockData);\n      \n      expect(result.data).toBeNull();\n      expect(result.error).toContain('Referência inválida');\n    });\n    \n    it('should sanitize forbidden fields', async () => {\n      const mockData = {\n        type: 'service',\n        value: 150.00,\n        date: '2025-10-18',\n        id: 'should-be-removed',\n        profit: 'should-be-removed'\n      };\n      \n      (supabase.from as jest.Mock).mockReturnValue({\n        insert: jest.fn().mockReturnValue({\n          select: jest.fn().mockReturnValue({\n            single: jest.fn().mockResolvedValue({\n              data: { id: 'new-id' },\n              error: null\n            })\n          })\n        })\n      });\n      \n      await revenueRepository.create(mockData);\n      \n      const insertCall = (supabase.from as jest.Mock).mock.results[0].value.insert;\n      const insertedData = insertCall.mock.calls[0][0];\n      \n      expect(insertedData).not.toHaveProperty('id');\n      expect(insertedData).not.toHaveProperty('profit');\n    });\n  });\n  \n  describe('findAll()', () => {\n    it('should fetch revenues with filters', async () => {\n      const mockRevenues = [\n        { id: '1', value: 100, type: 'service' },\n        { id: '2', value: 200, type: 'product' }\n      ];\n      \n      (supabase.from as jest.Mock).mockReturnValue({\n        select: jest.fn().mockReturnValue({\n          eq: jest.fn().mockReturnValue({\n            gte: jest.fn().mockReturnValue({\n              lte: jest.fn().mockReturnValue({\n                order: jest.fn().mockReturnValue({\n                  range: jest.fn().mockResolvedValue({\n                    data: mockRevenues,\n                    error: null,\n                    count: 2\n                  })\n                })\n              })\n            })\n          })\n        })\n      });\n      \n      const result = await revenueRepository.findAll(\n        { unit_id: 'abc123', start_date: '2025-10-01', end_date: '2025-10-31' },\n        { page: 1, limit: 50 }\n      );\n      \n      expect(result.data).toEqual(mockRevenues);\n      expect(result.count).toBe(2);\n      expect(result.error).toBeNull();\n    });\n  });\n});\n```\n\n---\n\n### **3. Testes de Service**\n\n**Arquivo:** `src/services/__tests__/financeiroService.spec.ts`\n\n```typescript\nimport financeiroService from '../financeiroService';\nimport revenueRepository from '../../repositories/revenueRepository';\nimport { CreateRevenueDTO } from '../../dtos/revenueDTO';\n\njest.mock('../../repositories/revenueRepository');\n\ndescribe('FinanceiroService', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  describe('createReceita()', () => {\n    it('should create receita with valid data', async () => {\n      const inputData = {\n        type: 'service',\n        value: 150.00,\n        date: '2025-10-18',\n        unit_id: 'abc123'\n      };\n      \n      const mockDbResponse = {\n        id: 'new-id',\n        ...inputData,\n        status: 'Pending',\n        created_at: '2025-10-18T14:30:00.000Z'\n      };\n      \n      (revenueRepository.create as jest.Mock).mockResolvedValue({\n        data: mockDbResponse,\n        error: null\n      });\n      \n      const result = await financeiroService.createReceita(inputData);\n      \n      expect(result.error).toBeNull();\n      expect(result.data).toHaveProperty('id', 'new-id');\n      expect(result.data.value).toBe(150.00);\n    });\n    \n    it('should reject invalid data before calling repository', async () => {\n      const invalidData = {\n        type: 'service',\n        value: -100, // Valor negativo\n        date: '2025-10-18'\n      };\n      \n      const result = await financeiroService.createReceita(invalidData);\n      \n      expect(result.error).toContain('maior que zero');\n      expect(result.data).toBeNull();\n      expect(revenueRepository.create).not.toHaveBeenCalled();\n    });\n    \n    it('should block forbidden fields', async () => {\n      const dataWithForbidden = {\n        type: 'service',\n        value: 150.00,\n        date: '2025-10-18',\n        valor: 'forbidden-field'\n      };\n      \n      const result = await financeiroService.createReceita(dataWithForbidden);\n      \n      expect(result.error).toContain('campos em português detectados');\n      expect(revenueRepository.create).not.toHaveBeenCalled();\n    });\n  });\n});\n```\n\n---\n\n## 🔗 Testes de Integração\n\n**Arquivo:** `src/__tests__/integration/financial-flow.spec.ts`\n\n```typescript\nimport financeiroService from '../../services/financeiroService';\nimport { supabase } from '../../services/supabase';\n\ndescribe('Financial Flow Integration', () => {\n  beforeAll(async () => {\n    // Setup: Limpar dados de teste\n    await supabase.from('revenues').delete().eq('is_test', true);\n  });\n  \n  afterAll(async () => {\n    // Cleanup: Remover dados de teste\n    await supabase.from('revenues').delete().eq('is_test', true);\n  });\n  \n  it('should complete full revenue creation flow', async () => {\n    const inputData = {\n      type: 'service',\n      value: 150.00,\n      date: '2025-10-18',\n      unit_id: process.env.TEST_UNIT_ID,\n      is_test: true\n    };\n    \n    // Criar receita\n    const createResult = await financeiroService.createReceita(inputData);\n    expect(createResult.error).toBeNull();\n    expect(createResult.data).toHaveProperty('id');\n    \n    const revenueId = createResult.data.id;\n    \n    // Buscar receita criada\n    const getResult = await financeiroService.getReceitaById(revenueId);\n    expect(getResult.error).toBeNull();\n    expect(getResult.data.value).toBe(150.00);\n    \n    // Atualizar status\n    const updateResult = await financeiroService.updateReceita(revenueId, {\n      status: 'Received',\n      actual_receipt_date: '2025-10-20'\n    });\n    expect(updateResult.error).toBeNull();\n    expect(updateResult.data.status).toBe('Received');\n    \n    // Deletar (soft delete)\n    const deleteResult = await financeiroService.deleteReceita(revenueId);\n    expect(deleteResult.success).toBe(true);\n  });\n});\n```\n\n---\n\n## ✅ Checklist de Testes\n\n### **DTO Tests**\n- [ ] Constructor com dados válidos\n- [ ] Constructor com null/undefined\n- [ ] Validação com dados válidos\n- [ ] Validação com campos obrigatórios faltando\n- [ ] Validação de tipos (string, number, date)\n- [ ] Validação de ranges (value > 0, length <= N)\n- [ ] Validação de ENUMs\n- [ ] Validação de UUIDs\n- [ ] toDatabase() remove campos proibidos\n- [ ] toDatabase() aplica whitelist\n\n### **Repository Tests**\n- [ ] create() com sucesso\n- [ ] create() com erro de banco\n- [ ] create() sanitiza campos proibidos\n- [ ] findAll() com filtros\n- [ ] findAll() com paginação\n- [ ] findById() encontra registro\n- [ ] findById() retorna erro se não encontrar\n- [ ] update() atualiza registro\n- [ ] softDelete() desativa registro\n\n### **Service Tests**\n- [ ] create() com dados válidos\n- [ ] create() rejeita dados inválidos\n- [ ] create() bloqueia campos proibidos\n- [ ] getAll() retorna DTOs transformados\n- [ ] getById() retorna DTO único\n- [ ] update() atualiza e retorna DTO\n- [ ] delete() executa soft delete\n\n### **Integration Tests**\n- [ ] Fluxo completo: criar → buscar → atualizar → deletar\n- [ ] RLS funciona corretamente\n- [ ] Triggers são executados\n- [ ] Validações de constraint do banco funcionam\n\n---\n\n## 🚀 Comandos de Teste\n\n```bash\n# Rodar todos os testes\nnpm test\n\n# Rodar apenas testes unitários\nnpm test -- --testPathPattern=__tests__/unit\n\n# Rodar apenas testes de integração\nnpm test -- --testPathPattern=__tests__/integration\n\n# Rodar com cobertura\nnpm run test:coverage\n\n# Rodar em modo watch\nnpm test -- --watch\n\n# Rodar testes de um arquivo específico\nnpm test -- revenueDTO.spec.ts\n```\n\n---\n\n**IMPORTANTE:** Cobertura mínima exigida: **80%** em todas as camadas.\n"
}
